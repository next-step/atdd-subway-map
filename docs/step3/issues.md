# week1 step 3 이슈

## dto 계층 및 의존성 분리

request dto를 인터페이스 계층에서 구성하고  도메인 계층의 service까지 내렸을 때 양방향 의존성이 생기는 문제에 대해서 공감했어요. 이를 해결하는 한 방법으로 도메인 계층에서 dto를 상황에 맞도록 최대한 유연하고 확장가능하게 사용하는 방식으로 풀어보고자 했습니다. 패키지와 클래스는 늘어나지만, 실제 업무에서는 결국에 작은 역할이더라도 분리를 해두는 것이 나중에가서 보면 유용하더라구요. 그런 의도를 담아서 들어오는 dto의 방향성에 따라서는 request -> command -> entity, 나가는 dto에 대해서는 entity -> info -> (response) 로 구성했어요. response는 시간 여유상 구상까지만 했습니다.


## mapper의 사용

object 변환이 매우 빈번해요. mapping 방식에는 다양한 방식이 있겠지만 저는 본 프로젝트에서의 구현처럼 Modelmapper나 Objectmapper를 커스텀으로 재구성해서 개발 편의성에 초점을 두는 것을 선호하는 편이에요. 매핑이 정말 많이 사용되기도 하고, 사람들마다 또 견해도 다른 것 같고, 또 성능 이슈도 있을 수 있는 것 같아요.

프로젝트에서 구현한 것처럼 자동화된 커스텀 매퍼를 사용하면서 주의해야 할 점 중 하나는 Line과 Section의 경우처럼 양방향 연관관계가 맺어진 경우인데요. 순환 참조 문제도 자동화할 수 있는 옵션을 찾아봤었는데 결국에는 못찾겠더라구요. 그래서 이런 경우는 skip 옵션을 주는 식으로 매핑을 제한하고 수동으로 해주고 있습니다.

리뷰어님께서는 실제 개발에서 어떤 매핑 방식으로 객체 변환을 하시는지 궁금합니다. 또 다양한 회사에서의 컨벤션도 어떨지 궁금해서 혹시 아신다면 나눠주실 수도 있을까요 ?! 👀


## 검증 로직에 대해서

서비스 레이어에서 검증 로직에 대해서 최근 고민하던 부분이 있었는데, 동일한 맥락의 고민을 이번 구현을 하면서도 만났어요. Crud 과정에서 제약사항에 대한 검증을 하는 것은 어떻게 보면 흔한 검증 플로우가 될 텐데요. 서비스에서 명시적인 검증을 해주되, 검증 책임을 별도의 validator를 통해 처리하는 것을 선호하고 있어요. 그런데 문제는, validation 로직이 여러 개가 늘어날 수록, 하나의 validator에서 이를 해결하고자 하면 private method가 쌓이게 되고, 테스트하기 어려운 코드가 돼요. 그런데 맥락상 validators를 여러 개로 나누기가 또 애매한 경우가 있구요.

한 가지 비즈니스 룰에 대해서는 해당 rule을 처리하는 별도의 클래스, 즉 Specification으로 검증 로직을 도입하고 싶었어요. 사실 이 부분을 이전부터 고민했었는데, 여기서의 문제는 추상화의 문제가 있더라구요. 즉, create에 대해서는 create에 대한 Specification만 구현이 가능하더라구요. 왜냐하면 delete, search, update 등등 다양한 연산에 대한 파라미터가 전부 다르고, 타입 추론 방식이 없어서 (혹은 제가 못찾아서) 공통 부분을 추출해서 추상화하기가 힘들다고 느꼈어요. 결국 비즈니스 룰에 거의 비례하게 validators와 specification이 생기게 됩니다.

그렇게 되었을 때, 분명 테스트하기 좋은 환경인 것은 맞지만 오버 엔지니어링이라고 느껴질 법하게 정말 작은 클래스들이 많이 생기기도 하고 조금 비효율적인 로직 같다는 생각도 듭니다.

프로젝트에서는 create에 대해서만 specification 방식으로 구현하고 delete는 일반적인 if 조건문으로 validation을 체크했어요. 사실 이 부분에 대해서 명확한 답을 스스로 내리지 못했고 찾아가는 중인 거 같아요!

리뷰어님의 도움이 필요합니다! 도와주세요.. ㅎㅎ 


---

원문글 링크
- https://github.com/next-step/atdd-subway-map/pull/1100#pullrequestreview-1855778168


